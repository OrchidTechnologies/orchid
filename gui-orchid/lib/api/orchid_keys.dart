import 'package:orchid/api/orchid_log.dart';
import 'package:orchid/api/preferences/user_preferences_keys.dart';
import 'package:orchid/api/orchid_crypto.dart';

class StoredEthereumKey {
  // A locally unique id for referencing this key in the persistence layer.
  final String uid;

  // The time at which this key was stored.
  final DateTime time;

  // True if this key was imported.  False if it was generated by us.
  final bool imported;

  // The EC private key
  final BigInt private;

  StoredEthereumKey({
    String? uid,
    DateTime? time,
    required this.imported,
    required this.private,
  })  : this.time = time ?? DateTime.now(),
        this.uid = uid ?? Crypto.uuid();

  EthereumKeyPair? _keyPair;

  EthereumAddress get address {
    return get().address;
  }

  EthereumKeyPair get() {
    if (_keyPair == null) {
      _keyPair = Crypto.fromPrivateKey(private);
    }
    return _keyPair!; // !
  }

  StoredEthereumKeyRef ref() {
    return StoredEthereumKeyRef(uid);
  }

  StoredEthereumKey.fromJson(Map<String, dynamic> json)
      : this.uid = json['uuid'] ?? json['time'].toString(),
        this.time = DateTime.fromMillisecondsSinceEpoch(json['time']),
        this.imported = json['imported'],
        this.private = BigInt.parse(json['private']);

  Map<String, dynamic> toJson() => {
        'uuid': uid,
        'time': time.millisecondsSinceEpoch,
        'imported': imported,
        'private': private.toString()
      };

  /// Format the secret as a 64 character hex string, zero padded, without prefix.
  String formatSecretFixed() {
    return private.toRadixString(16).padLeft(64, '0');
  }

  String toExportString() {
    return 'account={ secret: "${formatSecretFixed()}" }';
  }

  static Map<String, StoredEthereumKey> map(List<StoredEthereumKey> list) {
    return {for (var key in list) key.uid: key};
  }

  static StoredEthereumKey? findByUid(
      List<StoredEthereumKey> list, String uid) {
    try {
      return list.firstWhere((key) => key.uid == uid);
    } catch (err) {
      return null;
    }
  }

  static StoredEthereumKey? findByAddress(
      List<StoredEthereumKey> list, EthereumAddress signerAddress) {
    try {
      return list.firstWhere((key) => key.address == signerAddress);
    } catch (err) {
      return null;
    }
  }

  static StoredEthereumKey generate() {
    try {
      var secret = Crypto.generateKeyPair().private;
      return StoredEthereumKey(
        imported: false,
        time: DateTime.now(),
        uid: Crypto.uuid(),
        private: secret,
      );
    } catch (err) {
      log("Error in key generation!: $err");
      throw err;
    }
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StoredEthereumKey &&
          runtimeType == other.runtimeType &&
          uid == other.uid;

  @override
  int get hashCode => uid.hashCode;

  @override
  String toString() {
    return 'StoredEthereumKey{uid: $uid, address: $address, time: $time, imported: $imported}';
  }
}

/// Base class for StoredEthereumKeyRef and TransientEthereumKeyRef
abstract class EthereumKeyRef {
  final String keyUid;

  EthereumKeyRef(this.keyUid);

  // Resolve the reference to the key
  StoredEthereumKey get();

  EthereumAddress get address => get().address;

// Resolve the reference from a collection
  StoredEthereumKey getFrom(List<StoredEthereumKey> keys) {
    try {
      return keys.firstWhere((key) {
        return key.uid == keyUid;
      });
    } catch (err) {
      throw Exception("getFrom(key) error: $err");
    }
  }

  bool isFoundIn(List<StoredEthereumKey> keys) {
    return keys.map((e) => e.ref().keyUid).contains(keyUid);
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StoredEthereumKeyRef &&
          runtimeType == other.runtimeType &&
          keyUid == other.keyUid;

  @override
  int get hashCode => keyUid.hashCode;

  @override
  String toString() {
    return keyUid;
  }
}

/// A key ref that retrieves keys from user prefs.
class StoredEthereumKeyRef extends EthereumKeyRef {
  StoredEthereumKeyRef(String keyUid) : super(keyUid);

  @override
  StoredEthereumKey get() {
    var keys = UserPreferencesKeys().keys.get() ?? [];
    try {
      return getFrom(keys);
    } catch (err) {
      throw Exception("get key: uid=$keyUid error: $err");
    }
  }
}

/// A key ref that holds a potentially un-saved key.
class TransientEthereumKeyRef extends EthereumKeyRef {
  final StoredEthereumKey key;

  TransientEthereumKeyRef(this.key) : super(key.uid);

  @override
  StoredEthereumKey get() {
    return key;
  }
}
